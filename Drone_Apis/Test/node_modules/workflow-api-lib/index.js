'use strict';

var workflow_api_lib,
	async = require('async'),
	cjson = require('cjson'),
	rest = require('./libs/rest'),
	debug = require('debug')('workflow-api-lib');

module.exports = workflow_api_lib = {

	createRule: function(ruleConfig) {
		if (typeof(ruleConfig) === 'string') {
			ruleConfig = this.getConf(ruleConfig);
		}

		var rule = new Rule(ruleConfig);

		for (var name in ruleConfig.scripts) {
			rule.scripts[name] = require((ruleConfig.base || __dirname) + ruleConfig.scripts[name]);
		}

		ruleConfig.apis_files.forEach(function (file) {
			var json = cjson.load((ruleConfig.base || __dirname) + file + '.json');
			rule.apisInfo = cjson.extend(rule.apisInfo, json);
		});

		return rule;
	},

	getConf: function(path) {
		return cjson.load(__dirname + path);
	}
};

function Rule(ruleConfig) {
	this.ruleConfig = ruleConfig;
	this.results = {};
	this.props = {};
	this.scripts = {};
	this.apisInfo = {};
}

Rule.prototype = {
	clone: function() {
		var rule = new Rule(this.ruleConfig);
		rule.scripts = this.scripts;
		rule.apisInfo = this.apisInfo;
		return rule;
	},

	init: function(serverConfig, ruleName, body, callback) {
		var rule = this.clone(),
			exec;

		if (!(exec = rule.ruleConfig.rules[ruleName])) {
			throw new Error('Cannot find rule API: ' + ruleName);
		}

		rule.serverConfig = serverConfig;
		rule.version = exec.version;
		rule.callback = callback || function() {};
		rule.run(exec, body);

		return rule;
	},

	run: function(execParent, data) {
		var parallel = [],
			rule = this;

		if (data) {
			for (var key in execParent.declare) {
				var keys, value = execParent.declare[key];
				if (value.indexOf('#/') === 0) { //get from body
					keys = value.split('/');
					value = data;
					for (var i = 1; i < keys.length; i++) {
						value = value[keys[i]];
					}
				}
				this.props[key] = value;
			}
		}

		var runNext = function(method, path, exec, queries, body, header, result) {
			var server = new rest().init(rule.serverConfig);
			for (var key in header) {
				server.headers[key] = header[key];
			}
			return function(async_callback) {
				server.request(method, path,
								queries,
								body, function(error, data, req, res) {

					result.error = error;
					result.data = data;
					result.statusCode = res.statusCode;

					debug(result);

					if (exec.result) {
						if (typeof rule.scripts[exec.result.script] === "function") {
							return rule.scripts[exec.result.script](rule, exec, result, async_callback, req, res);
						}
						return rule.run(exec.result, data);
					}

					if (exec.failed && error) {
						rule.run(exec.failed, data);
					} else if (exec.success && !error) {
						rule.run(exec.success, data);
					} else {
						async_callback();
					}
				});
			};
		};

		for (var index in execParent.execute) {
			var exec = execParent.execute[index],
				apiVersion = rule.apisInfo[exec.version || rule.version] || {},
				apiInfo = apiVersion[exec.api];
			if (!apiInfo) {
				throw new Error('Cannot execute API: ' + exec.api);
			}

			var path = apiInfo.path,
				qjson = JSON.stringify(exec.queries || {}),
				bjson = JSON.stringify(exec.body || {}),
				hjson = JSON.stringify(exec.header || {}),
				result = {};

			rule.results[exec.name || exec.api] = result;

			for (var name in exec.path) {
				path = path.replace(new RegExp('\\(' + name + '\\)', 'g'), rule.props[exec.path[name]]);
			}

			for (name in rule.props) {
				qjson = qjson.replace(new RegExp(name, 'g'), rule.props[name]);
				bjson = bjson.replace(new RegExp(name, 'g'), rule.props[name]);
				hjson = hjson.replace(new RegExp(name, 'g'), rule.props[name]);
			}

			parallel.push(runNext(apiInfo.method, path, exec,
						JSON.parse(qjson),
						JSON.parse(bjson), 
						JSON.parse(hjson), result));
		}

		async.parallel(parallel, function() {
			rule.callback(rule.results);
		});
	}
};